(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{590:function(e,a,t){"use strict";t.r(a);var s=t(0),r=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"四种引用类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四种引用类型"}},[e._v("#")]),e._v(" 四种引用类型")]),e._v(" "),a("p",[e._v('JDK1.2 之前，一个对象只有“已被引用”和"未被引用"两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。')]),e._v(" "),a("p",[e._v("所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。")]),e._v(" "),a("h3",{attrs:{id:"强引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强引用"}},[e._v("#")]),e._v(" 强引用")]),e._v(" "),a("p",[e._v("Java中默认声明的就是强引用，比如：")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Object")]),e._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//只要obj还指向Object对象，Object对象就不会被回收")]),e._v("\nobj "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//手动置null")]),e._v("\n")])])]),a("p",[e._v("只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了")]),e._v(" "),a("h3",{attrs:{id:"软引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软引用"}},[e._v("#")]),e._v(" 软引用")]),e._v(" "),a("p",[e._v("软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。\n在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。")]),e._v(" "),a("h3",{attrs:{id:"弱引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#弱引用"}},[e._v("#")]),e._v(" 弱引用")]),e._v(" "),a("p",[e._v("弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。这种特性常常被用来实现ThreadLocal,在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。")]),e._v(" "),a("h3",{attrs:{id:"虚引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚引用"}},[e._v("#")]),e._v(" 虚引用")]),e._v(" "),a("p",[e._v("虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。")]),e._v(" "),a("h3",{attrs:{id:"引用队列-referencequeue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用队列-referencequeue"}},[e._v("#")]),e._v(" 引用队列（ReferenceQueue）")]),e._v(" "),a("p",[e._v("引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。")]),e._v(" "),a("p",[e._v("与软引用、弱引用不同，虚引用必须和引用队列一起使用。")]),e._v(" "),a("blockquote",[a("p",[e._v("https://www.cnblogs.com/liyutian/p/9690974.html")])])])}),[],!1,null,null,null);a.default=r.exports}}]);