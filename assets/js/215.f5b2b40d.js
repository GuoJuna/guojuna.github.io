(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{692:function(t,e,a){"use strict";a.r(e);var r=a(0),n=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"ext"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ext"}},[t._v("#")]),t._v(" Ext")]),t._v(" "),e("p",[t._v("sencha which")]),t._v(" "),e("p",[t._v("set PATH=%PATH%;C:\\Sencha\\Cmd\\6.0.0.92")]),t._v(" "),e("p",[t._v("sencha generate app --ext MyApp ./myapp\n将会创建名为 MyApp 的 Ext JS 应用，应用所有的文件都放在\n当前目录下名为 myapp 的文件夹。")]),t._v(" "),e("p",[t._v("extjs")]),t._v(" "),e("h2",{attrs:{id:"_1-基本结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本结构"}},[t._v("#")]),t._v(" 1.基本结构:")]),t._v(" "),e("p",[t._v("Ext.define('Car',{\nname:null,\nconstructor:function(name){\nif(name){\nthis.name=name;\n}\n},\nstart:function(){\nalert('Car started');\n}\n});")]),t._v(" "),e("h2",{attrs:{id:"_2-继承-extend"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-继承-extend"}},[t._v("#")]),t._v(" 2.继承: extend")]),t._v(" "),e("p",[t._v("Ext.define('ElectricCar',{\nextend:'Car',\nstart:function(){\nalert(\"Electric car started\");\n}")]),t._v(" "),e("p",[t._v("})")]),t._v(" "),e("h2",{attrs:{id:"_3-重写-override"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-重写-override"}},[t._v("#")]),t._v(" 3.重写:override")]),t._v(" "),e("p",[t._v("Ext.define('My.ux.field.Text',{\noverride:'Ext.form.field.Text',\nsetValue:function(val){\nthis.callParent(['In override']);\nreturn this;\n}\n})")]),t._v(" "),e("h2",{attrs:{id:"_4-总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-总结"}},[t._v("#")]),t._v(" 4.总结")]),t._v(" "),e("p",[t._v("extend 会创建一个新的类，并继承父类的属性和方法，你也可\n以重写父类的方法。而 override 并不会创建一个新的类，而是修改这个被重\n写的父类。")]),t._v(" "),e("h2",{attrs:{id:"_5-单例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-单例"}},[t._v("#")]),t._v(" 5.单例")]),t._v(" "),e("p",[t._v("singleton:true,")]),t._v(" "),e("h2",{attrs:{id:"_6-创建对象-ext-create-new-不推荐使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-创建对象-ext-create-new-不推荐使用"}},[t._v("#")]),t._v(" 6.创建对象 Ext.create new(不推荐使用)")]),t._v(" "),e("p",[t._v("Ext.create(Class,Options);")]),t._v(" "),e("p",[t._v("var myCar = Ext.create('ElectricCar',{name:'MyElectricCar'});")]),t._v(" "),e("h2",{attrs:{id:"_7-关闭ext-loader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-关闭ext-loader"}},[t._v("#")]),t._v(" 7.关闭Ext.Loader")]),t._v(" "),e("p",[t._v("Ext.Loader.setConfig({\nenabled:true\n});")]),t._v(" "),e("h2",{attrs:{id:"_8-onready"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-onready"}},[t._v("#")]),t._v(" 8.onReady")]),t._v(" "),e("p",[t._v("这个函数在页面加载完成后调用\nExt.onReady(function(){\nnew Ext.Component({\nrenderTo:document.body,\nhtml:'DOM ready!'\n});\n});")]),t._v(" "),e("h2",{attrs:{id:"_9-别名-alias-xtype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-别名-alias-xtype"}},[t._v("#")]),t._v(" 9.别名 alias xtype")]),t._v(" "),e("p",[t._v("alias:'widget.panel'")]),t._v(" "),e("p",[t._v("你也可以使用 xtype 为这个类给定一个别名。这个 xtype 是非常有用的，当\n你以指定 xtype 的方式应用部件时，并不会创建实例，而是在真正调用展示的\n时候才会创建这个类的实例。")]),t._v(" "),e("h2",{attrs:{id:"_10-widget-部件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-widget-部件"}},[t._v("#")]),t._v(" 10.widget(部件)")]),t._v(" "),e("p",[t._v("用别名创建实例\nExt.widget('panel',{}\nrenderTo:Ext.betBody(),\ntitle:'panel'\n);\n等价于Ext.create();")]),t._v(" "),e("h2",{attrs:{id:"_11-getclass"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-getclass"}},[t._v("#")]),t._v(" 11.getClass")]),t._v(" "),e("p",[t._v("如果创建的实例是用 Ext.define 定义的，那么返回这个给定对象的类，否则\n返回 null：\nvar button = new Ext.Button();\nExt.getClass(button);")]),t._v(" "),e("h2",{attrs:{id:"_12-getclassname"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-getclassname"}},[t._v("#")]),t._v(" 12.getClassName")]),t._v(" "),e("p",[t._v("通过它的应用或实例返回类的名称\nExt.getClassName(Ext.Button);")]),t._v(" "),e("h2",{attrs:{id:"_13-ext-base"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-ext-base"}},[t._v("#")]),t._v(" 13.Ext.Base")]),t._v(" "),e("p",[t._v("这是所有Ext类的基础.所有的Ext类都继承自Ext.Base.该类所有的原型和静态成员都会传递给它继承的类.")]),t._v(" "),e("h2",{attrs:{id:"_14-ext-class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-ext-class"}},[t._v("#")]),t._v(" 14.Ext.class")]),t._v(" "),e("p",[t._v("这是一个低级别的工厂类,用于通过Ext.ClassManager定义一个类.所以不应该在你的代码中直接访问,你应该使用Ext.difine")]),t._v(" "),e("h2",{attrs:{id:"_15-ext-classmanager"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-ext-classmanager"}},[t._v("#")]),t._v(" 15.Ext.ClassManager")]),t._v(" "),e("p",[t._v("它管理所有的类同时处理类反射.通常通过下面几个方法访问:\ndefine create widget getClass getClassName")]),t._v(" "),e("h2",{attrs:{id:"_16-ext-loader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-ext-loader"}},[t._v("#")]),t._v(" 16.Ext.loader")]),t._v(" "),e("p",[t._v("用于动态的加载依赖")]),t._v(" "),e("p",[t._v("Ext.require(['widget."),e("em",[t._v("', 'layout.")]),t._v("', 'Ext.data."),e("em",[t._v("');\n使用以下语法排除掉不需要的类：\nExt.exclude('Ext.data.")]),t._v("').require('*');")]),t._v(" "),e("p",[t._v("requires 属性加载需要的类时，当前类初始化之前被加载。\nuses 属性加载需要的类时，当前类初始化之后被加载。\nsingleton:true 属性当前类初始化时,该实例是一个单例对象。")]),t._v(" "),e("h2",{attrs:{id:"_17-events-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-events-事件"}},[t._v("#")]),t._v(" 17.Events(事件)")]),t._v(" "),e("h2",{attrs:{id:"_18-adding-listeners-为类添加监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-adding-listeners-为类添加监听"}},[t._v("#")]),t._v(" 18.Adding listeners(为类添加监听)")]),t._v(" "),e("p",[t._v("Ext.create('Ext.Button',{\nrenderTo:Ext.getBody(),\nlisteners:{\nclick:function(){\nExt.Msg.alert('Button clicked!');\n},\nmouseout:function(){\n//Do something\n}\n}\n});")]),t._v(" "),e("h2",{attrs:{id:"_19-removing-listeners-删除事件监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-removing-listeners-删除事件监听"}},[t._v("#")]),t._v(" 19.Removing listeners(删除事件监听)")]),t._v(" "),e("p",[t._v("var HandleClick=function(){\nExt.Msg.alert(\"my buttion clicked!\");\n}\nExt.create('Ext.Button',{\nlisteners:{\nclick:HandleClick\n}\n});")]),t._v(" "),e("p",[t._v("button.un('click',HandleClick);")]),t._v(" "),e("h2",{attrs:{id:"_20-页面dom元素的事件处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-页面dom元素的事件处理"}},[t._v("#")]),t._v(" 20.页面DOM元素的事件处理")]),t._v(" "),e("p",[t._v("var div=Ext.get('mydiv');\ndiv.on('click',function(e,t,e0pts){\n//do something\n});")]),t._v(" "),e("h2",{attrs:{id:"_21-访问dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-访问dom"}},[t._v("#")]),t._v(" 21.访问DOM")]),t._v(" "),e("p",[t._v("get query select")]),t._v(" "),e("p",[t._v("Ext.get 根据DOM元素的Id检索获取并封装为Ext.dom.Element对象\nvar mydiv = Ext.get('myDivId');\nExt.query 基于传入的CSS选择器,从给定的根节点开始查找,返回一个元素数组\nvar someNodes = Ext.query('.oddRow', myCustomComponent.getEl().dom);\nExt.select 给出一些 CSS/XPath 选择器，Ext.select 方法返回一个 CompositeElement类型的对象，代表一个元素的集合。\nvar rows = Ext.select('div,row');\nrow rows.setWidth(100);")]),t._v(" "),e("h2",{attrs:{id:"_22-多重选择器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-多重选择器"}},[t._v("#")]),t._v(" 22.多重选择器")]),t._v(" "),e("p",[t._v("Ext.select('div.row, span.title'); //匹配所有的 class 用 .row 的 div\n元素，和匹配所有 class 用 .title 的 span 元素")]),t._v(" "),e("p",[t._v("当你使用 select ，它默认取 HTML body 作为根并从默认的 body 开始检索整\n个 DOM 树。你可以通过制定一个根元素来避免这种情况，这样它将只搜索给定\n的根的子节点。\nExt.get('myEl').select('div.row');")]),t._v(" "),e("h2",{attrs:{id:"_23-链式选择器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23-链式选择器"}},[t._v("#")]),t._v(" 23.链式选择器")]),t._v(" "),e("p",[t._v("下列的查询方式会匹配 class 为 row 并且 title 属性值为 bar 的 div ，这\n个 div 属于其父元素的首个子元素：\nExt.select('div.row[title=bar]:first')")]),t._v(" "),e("h2",{attrs:{id:"_24-ext-componentquery-可以用id-xtype和属性查找一个组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24-ext-componentquery-可以用id-xtype和属性查找一个组件"}},[t._v("#")]),t._v(" 24.Ext.ComponentQuery 可以用ID,xtype和属性查找一个组件")]),t._v(" "),e("p",[t._v("下列查询将返回所有的 xtype 为 button 的组件：\nExt.ComponentQuery.query('button');\n得到一个 id 为 foo 的组件，用以下代码：\nExt.ComponentQuery.query('#foo');\n用嵌套选择器\nExt.ComponentQuery.query('formpanel numberfield'); // 这里获取 xtype\n为 frompanel 下面的 xtype 为 numberfield 的组件")]),t._v(" "),e("h2",{attrs:{id:"_25-组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25-组件"}},[t._v("#")]),t._v(" 25.组件")]),t._v(" "),e("p",[t._v("例如 button 和 label,所有的组件都派生自\nExt.Component 类，它提供支持创建，重绘，渲染和处理组件。\n所有的组件都有一个属性叫做 xtype 。它是非常有用的，它用在当你不想马上\n实例化这个组件时，而是想让这个组件在实际被应用时才创建，就是我们俗称\n的懒加载。")]),t._v(" "),e("h2",{attrs:{id:"_26-容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-容器"}},[t._v("#")]),t._v(" 26.容器")]),t._v(" "),e("p",[t._v("容器是一个特殊的组件类型，它能够持有其他组件。在 Ext JS 中\nExt.container.Container 类是所有的容器的基础类。")]),t._v(" "),e("p",[t._v("Ext.create('Ext.panel.Panel',{\nrenderTo:Ext.getBody(),\nwidth:700,\nheight:400,\nitems:[{\nxtype:'panel',\ntitle:'Panel 1',\n},{\nxtype:'panel',\ntitle:'Panel 2',\nheight:200,\nitems:[{\nxtype:'button',\ntext:'Click Me'\n}]\n},{\nxtype:'panel',\ntitle:'Panel 3',\nwidth:150,\nheight:100\n}\n}]\n})")]),t._v(" "),e("h2",{attrs:{id:"_27-absolute-绝对布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_27-absolute-绝对布局"}},[t._v("#")]),t._v(" 27.absolute 绝对布局")]),t._v(" "),e("p",[t._v("这个布局使用 x 和 y 属性来指定组件的绝对定位：")]),t._v(" "),e("h2",{attrs:{id:"_28-accordion-手风琴-可折叠-布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_28-accordion-手风琴-可折叠-布局"}},[t._v("#")]),t._v(" 28.accordion 手风琴(可折叠)布局")]),t._v(" "),e("p",[t._v("这个布局展示了在一个时间里只有一个内置的可支持折叠和展开的子级\npanel")]),t._v(" "),e("h2",{attrs:{id:"_29-anchor-锚点布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_29-anchor-锚点布局"}},[t._v("#")]),t._v(" 29.anchor 锚点布局")]),t._v(" "),e("p",[t._v("这个布局使你能够指定子级组件的大小，而这是相对于布局容器的。首先容器\n根据指定的锚点规则调整然后所有的子级组件再作调整：")]),t._v(" "),e("h2",{attrs:{id:"_30-border-布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_30-border-布局"}},[t._v("#")]),t._v(" 30.border 布局")]),t._v(" "),e("p",[t._v("这个布局允许你为子组件指定一个区域位置，例如 center，north，south，\nwest 和 east。当你使用 border 布局时，在其内的组件必须有一个指定区域\n为 center，如下列代码所示：")]),t._v(" "),e("h2",{attrs:{id:"_31-card-卡片布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_31-card-卡片布局"}},[t._v("#")]),t._v(" 31.card 卡片布局")]),t._v(" "),e("p",[t._v("在此布局中，只有一个子组件是可见的，这个组件基本上充满整个容器。卡片\n布局一般应用在向导或者 tabs：")]),t._v(" "),e("h2",{attrs:{id:"_32-center-中心布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_32-center-中心布局"}},[t._v("#")]),t._v(" 32.center 中心布局")]),t._v(" "),e("p",[t._v("这种布局，容器的子组件在中间。在本章中开始介绍布局的部分，我们已经有\n一个例子了。")]),t._v(" "),e("h2",{attrs:{id:"_33-column-列布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_33-column-列布局"}},[t._v("#")]),t._v(" 33.column 列布局")]),t._v(" "),e("p",[t._v("用此布局，你可以将容器划分为指定数量的列并指定每列所占的大小。这个例\n子也在本章开始介绍布局的部分中可以找到。")]),t._v(" "),e("h2",{attrs:{id:"_34-fit-适配布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_34-fit-适配布局"}},[t._v("#")]),t._v(" 34.fit 适配布局")]),t._v(" "),e("p",[t._v("在此布局中，子组件将会自适应容器的尺寸")]),t._v(" "),e("h2",{attrs:{id:"_35-hbox-布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_35-hbox-布局"}},[t._v("#")]),t._v(" 35.hbox 布局")]),t._v(" "),e("p",[t._v("这种布局与 column 布局几乎是一样的，但是这种布局允许你拉伸列的高度。\n这里使用 flex 选项为子组件设置水平的相对值：")]),t._v(" "),e("h2",{attrs:{id:"_36-table-表格布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_36-table-表格布局"}},[t._v("#")]),t._v(" 36.table 表格布局")]),t._v(" "),e("p",[t._v("这个布局允许你渲染一个表格出来。你可以指定列数和行数，使用 rowspan 和\ncolspan 创建复杂布局：")]),t._v(" "),e("h2",{attrs:{id:"_37-vbox-布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_37-vbox-布局"}},[t._v("#")]),t._v(" 37.VBox 布局")]),t._v(" "),e("p",[t._v("这个布局内，子组件是垂直向下一个接一个排列")])])}),[],!1,null,null,null);e.default=n.exports}}]);