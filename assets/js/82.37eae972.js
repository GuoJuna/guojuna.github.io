(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{569:function(n,t,e){"use strict";e.r(t);var r=e(0),i=Object(r.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("本文整理了常见的安全算法，包括MD5、SHA、DES、AES、RSA等，并写了完整的工具类（Java 版），工具类包含测试。")]),n._v(" "),t("h2",{attrs:{id:"一、数字摘要算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、数字摘要算法"}},[n._v("#")]),n._v(" 一、数字摘要算法")]),n._v(" "),t("blockquote",[t("p",[n._v('数字摘要也称为消息摘要，它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash函数对消息进行计算而产生。如果消息在传递的途中改变了，接收者通过对收到消息采用相同的Hash重新计算，新产生的摘要与原摘要进行比较，就可知道消息是否被篡改了，因此消息摘要能够验证消息的完整性。消息摘要采用单向Hash函数将需要计算的内容"摘要"成固定长度的串，这个串亦称为数字指纹。这个串有固定的长度，且不同的明文摘要成密文，其结果总是不同的(相对的)，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是"真身"的"指纹"了。')])]),n._v(" "),t("h3",{attrs:{id:"_1-md5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-md5"}},[n._v("#")]),n._v(" 1. Md5")]),n._v(" "),t("p",[n._v("MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。 MD5由MD4、 MD3、 MD2改进而来，主要增强算法复杂度和不可逆性，该算法因其普遍、稳定、快速的特点，在产业界得到了极为广泛的使用，目前主流的编程语言普遍都已有MD5算法实现。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Java.security.MessageDigest;\nimport Java.security.NoSuchAlgorithmException;\n\n/**\n * Message Digest Algorithm 5(信息摘要算法5)\n */\npublic class MD5Util {\n\t/**\n\t * Constructs the MD5Util object and sets the string whose MD5Util is to be\n\t * computed.\n\t * \n\t * @param inStr\n\t *    the <code>String</code> whose MD5Util is to be computed\n\t */\n\t\n\t\n\tpublic final static String COMMON_KEY=\"zhongzhuoxin#@!321\";\n\tpublic MD5Util() {\n\n\t}\n\n\tpublic final static String str2MD5(String inStr) {\n\t\tchar hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t\t\t\t'a', 'b', 'c', 'd', 'e', 'f' };\n\t\ttry {\n\t\t\tbyte[] strTemp = inStr.getBytes(\"UTF-8\");\n\t\t\tMessageDigest mdTemp = MessageDigest.getInstance(\"MD5\");\n\t\t\tmdTemp.update(strTemp);\n\t\t\tbyte[] md = mdTemp.digest();\n\t\t\tint j = md.length;\n\t\t\tchar str[] = new char[j * 2];\n\t\t\tint k = 0;\n\t\t\tfor (int i = 0; i < j; i++) {\n\t\t\t\tbyte byte0 = md[i];\n\t\t\t\tstr[k++] = hexDigits[byte0 >>> 4 & 0xf];\n\t\t\t\tstr[k++] = hexDigits[byte0 & 0xf];\n\t\t\t}\n\t\t\treturn new String(str);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\t//--MD5Util\n\tprivate static final char HEX_DIGITS[] = { '0', '1', '2', '3', '4', '5',\n\t\t\t'6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n\n\tpublic static String toHexString(byte[] b) { // String to byte\n\t\tStringBuilder sb = new StringBuilder(b.length * 2);\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tsb.append(HEX_DIGITS[(b[i] & 0xf0) >>> 4]);\n\t\t\tsb.append(HEX_DIGITS[b[i] & 0x0f]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static String AndroidMd5(String s) {\n\t\ttry {\n\t\t\t// Create MD5Util Hash\n\t\t\tMessageDigest digest = MessageDigest\n\t\t\t\t\t.getInstance(\"MD5\");\n\t\t\tdigest.update(s.getBytes());\n\t\t\tbyte messageDigest[] = digest.digest();\n\n\t\t\treturn toHexString(messageDigest);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tString m = MD5Util.str2MD5(\"swwwwwwwwwwdkinner\");\n\n\t\tSystem.out.print(m.length() + \"    \");\n\t\tSystem.out.println(m);\n\n\t}\n}\n\n")])])]),t("p",[n._v("###2.SHA")]),n._v(" "),t("p",[n._v("SHA的全称是Secure Hash Algorithm，即安全散列算法。 1993年，安全散列算法(SHA)由美国国家标准和技术协会（NIST)提出，并作为联邦信息处理标准(FIPS PUB 180)公布， 1995年又发布了一个修订版FIPS PUB 180-1，通常称之为SHA-1。 SHA-1是基于MD4算法的，现在已成为公认的最安全的散列算法之一，并被广泛使用。SHA-1算法生成的摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\n\nimport com.google.common.base.Strings;\n\nimport Java.security.MessageDigest;\n\n/**\n * SHA的全称是Secure Hash Algorithm，即安全散列算法\n * Created by guojun on 2017/3/21.\n */\npublic class SHAUtil {\n\n    /**\n     * 定义加密方式\n     */\n    private final static String KEY_SHA = "SHA";\n    private final static String KEY_SHA1 = "SHA-1";\n    /**\n     * 全局数组\n     */\n    private final static String[] hexDigits = { "0", "1", "2", "3", "4", "5",\n            "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" };\n\n    /**\n     * 构造函数\n     */\n    public SHAUtil() {\n\n    }\n\n    /**\n     * SHA 加密\n     * @param data 需要加密的字节数组\n     * @return 加密之后的字节数组\n     * @throws Exception\n     */\n    public static byte[] encryptSHA(byte[] data) throws Exception {\n        // 创建具有指定算法名称的信息摘要\n//        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);\n        MessageDigest sha = MessageDigest.getInstance(KEY_SHA1);\n        // 使用指定的字节数组对摘要进行最后更新\n        sha.update(data);\n        // 完成摘要计算并返回\n        return sha.digest();\n    }\n\n    /**\n     * SHA 加密\n     * @param data 需要加密的字符串\n     * @return 加密之后的字符串\n     * @throws Exception\n     */\n    public static String encryptSHA(String data) throws Exception {\n        // 验证传入的字符串\n        if (Strings.isNullOrEmpty(data)) {\n            return "";\n        }\n        // 创建具有指定算法名称的信息摘要\n        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);\n        // 使用指定的字节数组对摘要进行最后更新\n        sha.update(data.getBytes());\n        // 完成摘要计算\n        byte[] bytes = sha.digest();\n        // 将得到的字节数组变成字符串返回\n        return byteArrayToHexString(bytes);\n    }\n\n    /**\n     * 将一个字节转化成十六进制形式的字符串\n     * @param b 字节数组\n     * @return 字符串\n     */\n    private static String byteToHexString(byte b) {\n        int ret = b;\n        //System.out.println("ret = " + ret);\n        if (ret < 0) {\n            ret += 256;\n        }\n        int m = ret / 16;\n        int n = ret % 16;\n        return hexDigits[m] + hexDigits[n];\n    }\n\n    /**\n     * 转换字节数组为十六进制字符串\n     * @param bytes 字节数组\n     * @return 十六进制字符串\n     */\n    private static String byteArrayToHexString(byte[] bytes) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < bytes.length; i++) {\n            sb.append(byteToHexString(bytes[i]));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 测试方法\n     * @param args\n     */\n    public static void main(String[] args) throws Exception {\n        String key = "123";\n        System.out.println(encryptSHA(key));\n    }\n}\n\n')])])]),t("h2",{attrs:{id:"二、对称加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、对称加密"}},[n._v("#")]),n._v(" 二、对称加密")]),n._v(" "),t("blockquote",[t("p",[n._v("对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密，这就要求加密和解密方事先都必须知道加密的密钥。")])]),n._v(" "),t("h3",{attrs:{id:"_1-des算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-des算法"}},[n._v("#")]),n._v(" 1. DES算法")]),n._v(" "),t("p",[n._v("1973 年，美国国家标准局(NBS)在认识到建立数据保护标准既明显又急迫的情况下，开始征集联邦数据加密标准的方案。 1975 年3月17日， NBS公布了IBM公司提供的密码算法，以标准建议的形式在全国范围内征求意见。经过两年多的公开讨论之后， 1977 年7月15日， NBS宣布接受这建议，作为联邦信息处理标准46 号数据加密标准(Data Encryptin Standard)，即DES正式颁布，供商业界和非国防性政府部门使用。DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES\n运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解，因此演变出了3DES算法。 3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\n\nimport Java.io.IOException;\nimport Java.security.SecureRandom;\n\nimport Javax.crypto.Cipher;\nimport Javax.crypto.SecretKey;\nimport Javax.crypto.SecretKeyFactory;\nimport Javax.crypto.spec.DESKeySpec;\n\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n/**\n * Data Encryptin Standard\n * 数据加密标准\n */\npublic class DESUtil {\n\n\n    private final static String DES = "DES";\n\n    /**\n     * Description 根据键值进行加密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws Exception\n     */\n    public static String encrypt(String data, String key) throws Exception {\n        byte[] bt = encrypt(data.getBytes(), key.getBytes());\n        String strs = new BASE64Encoder().encode(bt);\n        return strs;\n    }\n\n    /**\n     * Description 根据键值进行解密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws IOException\n     * @throws Exception\n     */\n    public static String decrypt(String data, String key) throws Exception,\n            Exception {\n        if (data == null)\n            return null;\n        BASE64Decoder decoder = new BASE64Decoder();\n        byte[] buf = decoder.decodeBuffer(data);\n        byte[] bt = decrypt(buf, key.getBytes());\n        return new String(bt);\n    }\n\n    /**\n     * Description 根据键值进行加密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws Exception\n     */\n    private static byte[] encrypt(byte[] data, byte[] key) throws Exception {\n        // 生成一个可信任的随机数源\n        SecureRandom sr = new SecureRandom();\n\n        // 从原始密钥数据创建DESKeySpec对象\n        DESKeySpec dks = new DESKeySpec(key);\n\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\n        SecretKey securekey = keyFactory.generateSecret(dks);\n\n        // Cipher对象实际完成加密操作\n        Cipher cipher = Cipher.getInstance(DES);\n\n        // 用密钥初始化Cipher对象\n        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);\n\n        return cipher.doFinal(data);\n    }\n\n\n    /**\n     * Description 根据键值进行解密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws Exception\n     */\n    private static byte[] decrypt(byte[] data, byte[] key) throws Exception {\n        // 生成一个可信任的随机数源\n        SecureRandom sr = new SecureRandom();\n\n        // 从原始密钥数据创建DESKeySpec对象\n        DESKeySpec dks = new DESKeySpec(key);\n\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\n        SecretKey securekey = keyFactory.generateSecret(dks);\n\n        // Cipher对象实际完成解密操作\n        Cipher cipher = Cipher.getInstance(DES);\n\n        // 用密钥初始化Cipher对象\n        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);\n\n        return cipher.doFinal(data);\n    }\n\n    public static void main(String[]args)throws Exception{\n       String  sStr=encrypt("122222112222:12343232323:jajwwwwslwskwkkwksk","wew2323w233321ws233w");\n       System.out.println(sStr);\n       String mStr=decrypt(sStr,"wew2323w233321ws233w");\n       System.out.println(mStr);\n    }\n}\n\n')])])]),t("h3",{attrs:{id:"_2-aes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-aes"}},[n._v("#")]),n._v(" 2. AES")]),n._v(" "),t("p",[n._v("AES的全称是Advanced Encryption Standard，即高级加密标准，该算法由比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，又称Rijndael加密算法，是美国联邦政府采用的一种对称加密标准，这个标准用来替代原先的DES算法，已经广为全世界所使用，已然成为对称加密算法中最流行的算法之一。AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优\n点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\nimport Java.io.IOException;\nimport Java.io.UnsupportedEncodingException;\nimport Java.security.InvalidKeyException;\nimport Java.security.NoSuchAlgorithmException;\nimport Java.security.SecureRandom;\nimport Java.util.Base64;\nimport Java.util.Scanner;\n\nimport Javax.crypto.BadPaddingException;\nimport Javax.crypto.Cipher;\nimport Javax.crypto.IllegalBlockSizeException;\nimport Javax.crypto.KeyGenerator;\nimport Javax.crypto.NoSuchPaddingException;\nimport Javax.crypto.SecretKey;\nimport Javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n/**\n * Created by guojun on 2017/3/21.\n */\npublic class AESUtil {\n\n    static  byte[]  key = "w@#$4@#$s^&3*&^4".getBytes();\n    final static String algorithm="AES";\n\n    public static String encrypt(String data){\n\n        byte[] dataToSend = data.getBytes();\n        Cipher c = null;\n        try {\n            c = Cipher.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        SecretKeySpec k =  new SecretKeySpec(key, algorithm);\n        try {\n            c.init(Cipher.ENCRYPT_MODE, k);\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        byte[] encryptedData = "".getBytes();\n        try {\n            encryptedData = c.doFinal(dataToSend);\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        byte[] encryptedByteValue =     Base64.getEncoder().encode(encryptedData);\n        return  new String(encryptedByteValue);//.toString();\n    }\n\n    public static String decrypt(String data){\n\n        byte[] encryptedData  =  Base64.getDecoder().decode(data);\n        Cipher c = null;\n        try {\n            c = Cipher.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        SecretKeySpec k =\n                new SecretKeySpec(key, algorithm);\n        try {\n            c.init(Cipher.DECRYPT_MODE, k);\n        } catch (InvalidKeyException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n        byte[] decrypted = null;\n        try {\n            decrypted = c.doFinal(encryptedData);\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return new String(decrypted);\n    }\n\n    public static void main(String[] args){\n        String password=encrypt("12233440988:1239874389888:dd333");\n        System.out.println(password);\n        System.out.println(decrypt(password));\n    }\n}\n\n\n')])])]),t("p",[n._v("##三、非对称加密")]),n._v(" "),t("blockquote",[t("p",[n._v("非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。")])]),n._v(" "),t("h3",{attrs:{id:"rsa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rsa"}},[n._v("#")]),n._v(" RSA")]),n._v(" "),t("p",[n._v("RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发的， RSA取名来自开发他们三者的名字。 RSA是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。 RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\n/**\n * Created by guojun on 2017/3/21.\n * RSA ：RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发   *  的， RSA取名来\n *  自开发他们三者的名字。\n * 参考：http://blog.csdn.net/wangqiuyun/article/details/42143957\n */\n\nimport Java.io.*;\nimport Java.security.InvalidKeyException;\nimport Java.security.KeyFactory;\nimport Java.security.KeyPair;\nimport Java.security.KeyPairGenerator;\nimport Java.security.NoSuchAlgorithmException;\nimport Java.security.SecureRandom;\n\nimport Java.security.interfaces.RSAPrivateKey;\nimport Java.security.interfaces.RSAPublicKey;\nimport Java.security.spec.InvalidKeySpecException;\nimport Java.security.spec.PKCS8EncodedKeySpec;\nimport Java.security.spec.X509EncodedKeySpec;\nimport Java.util.Base64;\n\nimport Javax.crypto.BadPaddingException;\nimport Javax.crypto.Cipher;\nimport Javax.crypto.IllegalBlockSizeException;\nimport Javax.crypto.NoSuchPaddingException;\npublic class RSAUtil {\n\n\n    /**\n     * 字节数据转字符串专用集合\n     */\n    private static final char[] HEX_CHAR = { \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\',\n            \'7\', \'8\', \'9\', \'a\', \'b\', \'c\', \'d\', \'e\', \'f\' };\n\n    /**\n     * 随机生成密钥对\n     */\n    public static void genKeyPair(String filePath) {\n        // KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象\n        KeyPairGenerator keyPairGen = null;\n        try {\n            keyPairGen = KeyPairGenerator.getInstance("RSA");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        // 初始化密钥对生成器，密钥大小为96-1024位\n        keyPairGen.initialize(1024,new SecureRandom());\n        // 生成一个密钥对，保存在keyPair中\n        KeyPair keyPair = keyPairGen.generateKeyPair();\n        // 得到私钥\n        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n        // 得到公钥\n        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n        try {\n            // 得到公钥字符串\n            // 得到私钥字符串\n            String privateKeyString =new String( Base64.getEncoder().encode(privateKey.getEncoded()));\n            String publicKeyString =new String( Base64.getEncoder().encode(publicKey.getEncoded()));\n            // 将密钥对写入到文件\n\n            File file1=new File(filePath + "publicKey.keystore");\n            File file2=new File(filePath + "privateKey.keystore");\n            if(!file1.exists()) {\n                file1.createNewFile();\n            }\n            if(!file2.exists()) {\n                file2.createNewFile();\n            }\n            FileWriter pubfw = new FileWriter(filePath + "/publicKey.keystore");\n            FileWriter prifw = new FileWriter(filePath + "/privateKey.keystore");\n            BufferedWriter pubbw = new BufferedWriter(pubfw);\n            BufferedWriter pribw = new BufferedWriter(prifw);\n            pubbw.write(publicKeyString);\n            pribw.write(privateKeyString);\n            pubbw.flush();\n            pubbw.close();\n            pubfw.close();\n            pribw.flush();\n            pribw.close();\n            prifw.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 从文件中输入流中加载公钥\n     *\n     * @param\n     *\n     * @throws Exception\n     *             加载公钥时产生的异常\n     */\n    public static String loadPublicKeyByFile(String path) throws Exception {\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(path\n                    + "/publicKey.keystore"));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                sb.append(readLine);\n            }\n            br.close();\n            return sb.toString();\n        } catch (IOException e) {\n            throw new Exception("公钥数据流读取错误");\n        } catch (NullPointerException e) {\n            throw new Exception("公钥输入流为空");\n        }\n    }\n\n    /**\n     * 从字符串中加载公钥\n     *\n     * @param publicKeyStr\n     *            公钥数据字符串\n     * @throws Exception\n     *             加载公钥时产生的异常\n     */\n    public static RSAPublicKey loadPublicKeyByStr(String publicKeyStr)\n            throws Exception {\n        try {\n            byte[] buffer = Base64.getDecoder().decode(publicKeyStr);\n            KeyFactory keyFactory = KeyFactory.getInstance("RSA");\n            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);\n            return (RSAPublicKey) keyFactory.generatePublic(keySpec);\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此算法");\n        } catch (InvalidKeySpecException e) {\n            throw new Exception("公钥非法");\n        } catch (NullPointerException e) {\n            throw new Exception("公钥数据为空");\n        }\n    }\n\n    /**\n     * 从文件中加载私钥\n     *\n     * @param\n     *\n     * @return 是否成功\n     * @throws Exception\n     */\n    public static String loadPrivateKeyByFile(String path) throws Exception {\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(path\n                    + "/privateKey.keystore"));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                sb.append(readLine);\n            }\n            br.close();\n            return sb.toString();\n        } catch (IOException e) {\n            throw new Exception("私钥数据读取错误");\n        } catch (NullPointerException e) {\n            throw new Exception("私钥输入流为空");\n        }\n    }\n\n    public static RSAPrivateKey loadPrivateKeyByStr(String privateKeyStr)\n            throws Exception {\n        try {\n            byte[] buffer = Base64.getDecoder().decode(privateKeyStr);\n            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(buffer);\n            KeyFactory keyFactory = KeyFactory.getInstance("RSA");\n            return (RSAPrivateKey) keyFactory.generatePrivate(keySpec);\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此算法");\n        } catch (InvalidKeySpecException e) {\n            throw new Exception("私钥非法");\n        } catch (NullPointerException e) {\n            throw new Exception("私钥数据为空");\n        }\n    }\n\n    /**\n     * 公钥加密过程\n     *\n     * @param publicKey\n     *            公钥\n     * @param plainTextData\n     *            明文数据\n     * @return\n     * @throws Exception\n     *             加密过程中的异常信息\n     */\n    public static byte[] encrypt(RSAPublicKey publicKey, byte[] plainTextData)\n            throws Exception {\n        if (publicKey == null) {\n            throw new Exception("加密公钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            // cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n            byte[] output = cipher.doFinal(plainTextData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此加密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("加密公钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("明文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("明文数据已损坏");\n        }\n    }\n\n    /**\n     * 私钥加密过程\n     *\n     * @param privateKey\n     *            私钥\n     * @param plainTextData\n     *            明文数据\n     * @return\n     * @throws Exception\n     *             加密过程中的异常信息\n     */\n    public static byte[] encrypt(RSAPrivateKey privateKey, byte[] plainTextData)\n            throws Exception {\n        if (privateKey == null) {\n            throw new Exception("加密私钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n            byte[] output = cipher.doFinal(plainTextData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此加密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("加密私钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("明文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("明文数据已损坏");\n        }\n    }\n\n    /**\n     * 私钥解密过程\n     *\n     * @param privateKey\n     *            私钥\n     * @param cipherData\n     *            密文数据\n     * @return 明文\n     * @throws Exception\n     *             解密过程中的异常信息\n     */\n    public static byte[] decrypt(RSAPrivateKey privateKey, byte[] cipherData)\n            throws Exception {\n        if (privateKey == null) {\n            throw new Exception("解密私钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            // cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            byte[] output = cipher.doFinal(cipherData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此解密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("解密私钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("密文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("密文数据已损坏");\n        }\n    }\n\n    /**\n     * 公钥解密过程\n     *\n     * @param publicKey\n     *            公钥\n     * @param cipherData\n     *            密文数据\n     * @return 明文\n     * @throws Exception\n     *             解密过程中的异常信息\n     */\n    public static byte[] decrypt(RSAPublicKey publicKey, byte[] cipherData)\n            throws Exception {\n        if (publicKey == null) {\n            throw new Exception("解密公钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            // cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());\n            cipher.init(Cipher.DECRYPT_MODE, publicKey);\n            byte[] output = cipher.doFinal(cipherData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此解密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("解密公钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("密文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("密文数据已损坏");\n        }\n    }\n\n    /**\n     * 字节数据转十六进制字符串\n     *\n     * @param data\n     *            输入数据\n     * @return 十六进制内容\n     */\n    public static String byteArrayToString(byte[] data) {\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < data.length; i++) {\n            // 取出字节的高四位 作为索引得到相应的十六进制标识符 注意无符号右移\n            stringBuilder.append(HEX_CHAR[(data[i] & 0xf0) >>> 4]);\n            // 取出字节的低四位 作为索引得到相应的十六进制标识符\n            stringBuilder.append(HEX_CHAR[(data[i] & 0x0f)]);\n            if (i < data.length - 1) {\n                stringBuilder.append(\' \');\n            }\n        }\n        return stringBuilder.toString();\n    }\n\n\n\n    public static void main(String[] args) throws Exception {\n        String filepath="F:/temp/";\n        File file=new File(filepath);\n        if(!file.exists()){\n            file.mkdir();\n        }\n        genKeyPair(filepath);\n        System.out.println("--------------公钥加密私钥解密过程-------------------");\n        String plainText="1223333323:8783737321232:dewejj28i33e92hhsxxxx";\n        //公钥加密过程\n        byte[] cipherData=encrypt(loadPublicKeyByStr(loadPublicKeyByFile(filepath)),plainText.getBytes());\n        String cipher=new String(Base64.getEncoder().encode(cipherData));\n        //私钥解密过程\n        byte[] res=decrypt(loadPrivateKeyByStr(loadPrivateKeyByFile(filepath)), Base64.getDecoder().decode(cipher));\n        String restr=new String(res);\n        System.out.println("原文："+plainText);\n        System.out.println("加密密文："+cipher);\n        System.out.println("解密："+restr);\n        System.out.println();\n    }\n}\n\n')])])]),t("p",[n._v("注： 文字部分复制了《大型电商分布式系统实践 第一版 讲师 陈康贤》的第三课。代码来源于自己的整理，全部测试通过，应该没有坑。")])])}),[],!1,null,null,null);t.default=i.exports}}]);