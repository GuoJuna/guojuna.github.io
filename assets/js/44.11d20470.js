(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{522:function(t,e,r){"use strict";r.r(e);var n=r(0),a=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"设计模式简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式简介"}},[t._v("#")]),t._v(" 设计模式简介")]),t._v(" "),e("p",[t._v("设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。")]),t._v(" "),e("p",[t._v("设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。")]),t._v(" "),e("h2",{attrs:{id:"设计模式类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式类型"}},[t._v("#")]),t._v(" 设计模式类型")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("创建型模式")]),t._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/2-Factory-pattern.html"}},[t._v("工厂模式 (Factory pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/3-abstract-factory-pattern.html"}},[t._v("抽象工厂模式 (Abstract Factory Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/4-singleton-pattern.html"}},[t._v("单例模式 (singleton Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/5-builder-pattern.html"}},[t._v("建造者模式 (Builder Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/6-prototype-pattern.html"}},[t._v("原型模式 (Prototype Pattern)")])],1)])]),t._v(" "),e("li",[e("p",[t._v("结构型模式")]),t._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/7-adapter-pattern.html"}},[t._v("适配器模式 (Adapter Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/11-decorator-pattern.html"}},[t._v("装饰器模式 (Decorator Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/14-proxy-pattern.html"}},[t._v("代理模式 (Proxy Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/12-facade-pattern.html"}},[t._v("外观模式 (Facade Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/8-bridge-pattern.html"}},[t._v("桥接模式 (Bridge Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/10-composite-pattern.html"}},[t._v("组合模式 (Composite Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/13-flyweight-pattern.html"}},[t._v("享元模式 (Flyweight Pattern)")])],1)])]),t._v(" "),e("li",[e("p",[t._v("行为型模式")]),t._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/15-chain-responsibility-pattern.html"}},[t._v("责任链模式 (Chain of Responsibility Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/19-strategy-pattern.html"}},[t._v("策略模式 (Strategy Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/20-template-pattern.html"}},[t._v("模板模式 (Template Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/21-observer-pattern.html"}},[t._v("观察者模式 (Observer Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/18-iterator-pattern.html"}},[t._v("迭代器模式 (Iterator Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/16-command-pattern.html"}},[t._v("命令模式 (Command Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/22-memento-pattern.html"}},[t._v("备忘录模式 (Memento Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/23-state-pattern.html"}},[t._v("状态模式 (State Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/24-visitor-pattern.html"}},[t._v("访问者模式 (Visitor Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/9-mediator-pattern.html"}},[t._v("中介者模式 (Mediator Pattern)")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/blogs/designPattern/17-interpreter-pattern.html"}},[t._v("解释器模式 (Interpreter Pattern)")])],1)])])]),t._v(" "),e("h2",{attrs:{id:"设计模式的六大原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的六大原则"}},[t._v("#")]),t._v(" 设计模式的六大原则")]),t._v(" "),e("p",[t._v("1、开闭原则（Open Close Principle）")]),t._v(" "),e("p",[t._v("开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。")]),t._v(" "),e("p",[t._v("2、里氏代换原则（Liskov Substitution Principle）")]),t._v(" "),e("p",[t._v("里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。")]),t._v(" "),e("p",[t._v("3、依赖倒转原则（Dependence Inversion Principle）")]),t._v(" "),e("p",[t._v("这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。")]),t._v(" "),e("p",[t._v("4、接口隔离原则（Interface Segregation Principle）")]),t._v(" "),e("p",[t._v("这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。")]),t._v(" "),e("p",[t._v("5、迪米特法则，又称最少知道原则（Demeter Principle）")]),t._v(" "),e("p",[t._v("最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。")]),t._v(" "),e("p",[t._v("6、合成复用原则（Composite Reuse Principle）")]),t._v(" "),e("p",[t._v("合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。")])])}),[],!1,null,null,null);e.default=a.exports}}]);