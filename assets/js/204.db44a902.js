(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{613:function(r,t,n){"use strict";n.r(t);var e=n(0),a=Object(e.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("ol",[t("li",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" 关于 hashCode 和 equals 的处理，遵循如下规则：")])]),r._v(" "),t("blockquote",[t("p",[r._v("1） 只要覆写 equals，就必须覆写 hashCode。"),t("br"),r._v("\n2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写\n这两种方法。"),t("br"),r._v("\n3） 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。"),t("br"),r._v("\n说明：String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。")])]),r._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" 判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。")])]),r._v(" "),t("blockquote",[t("p",[r._v("说明：在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。"),t("br"),r._v("\n正例："),t("br"),r._v("\nMap\\<String, Object> map = new HashMap\\<>(16);"),t("br"),r._v("\nif(map.isEmpty()) {"),t("br"),r._v('\nSystem.out.println("no element in this map.");'),t("br"),r._v("\n}")])]),r._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" 在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使\n用含有参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key\n值时会抛出 IllegalStateException 异常。")])]),r._v(" "),t("blockquote",[t("p",[r._v("说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。"),t("br"),r._v("\n正例："),t("br"),r._v("\nList<Pair<String, Double>> pairArrayList = new ArrayList<>(3);"),t("br"),r._v('\npairArrayList.add(new Pair<>("version", 12.10));'),t("br"),r._v('\npairArrayList.add(new Pair<>("version", 12.19));'),t("br"),r._v('\npairArrayList.add(new Pair<>("version", 6.28));'),t("br"),r._v("\nMap<String, Double> map = pairArrayList.stream().collect("),t("br"),r._v("\n// 生成的 map 集合中只有一个键值对：{version=6.28}"),t("br"),r._v("\nCollectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));"),t("br"),r._v("\n反例："),t("br"),r._v('\nString[] departments = new String[] {"iERP", "iERP", "EIBU"};'),t("br"),r._v("\n// 抛出 IllegalStateException 异常"),t("br"),r._v("\nMap<Integer, String> map = Arrays.stream(departments)"),t("br"),r._v("\n.collect(Collectors.toMap(String::hashCode, str -> str));")])]),r._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" 在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要注\n意当 value 为 null 时会抛 NPE 异常。")])]),r._v(" "),t("blockquote",[t("p",[r._v("说明：在 java.util.HashMap 的 merge 方法里会进行如下的判断："),t("br"),r._v("\nif (value == null || remappingFunction == null)"),t("br"),r._v("\nthrow new NullPointerException();"),t("br"),r._v("\n反例："),t("br"),r._v("\nList<Pair<String, Double>> pairArrayList = new ArrayList<>(2);"),t("br"),r._v('\npairArrayList.add(new Pair<>("version1", 8.3));'),t("br"),r._v('\npairArrayList.add(new Pair<>("version2", null));'),t("br"),r._v("\nMap<String, Double> map = pairArrayList.stream().collect("),t("br"),r._v("\n// 抛出 NullPointerException 异常"),t("br"),r._v("\nCollectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));")])]),r._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异\n常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。")])]),r._v(" "),t("blockquote",[t("p",[r._v("说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视\n图，对于 SubList 的所有操作最终会反映到原列表上。")])]),r._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[t("p",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" 使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行添\n加元素操作，否则会抛出 UnsupportedOperationException 异常。")])]),r._v(" "),t("li",[t("p",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list，\n不可对其进行添加或者删除元素的操作。")])])]),r._v(" "),t("blockquote",[t("p",[r._v("反例：如果查询无结果，返回 Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就\n会触发 UnsupportedOperationException 异常。")])]),r._v(" "),t("ol",{attrs:{start:"8"}},[t("li",[t("p",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" 在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、\n增加、删除产生 ConcurrentModificationException 异常。")])]),r._v(" "),t("li",[t("p",[t("em",[t("strong",[r._v("【强制】")])]),r._v(" 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一\n致、长度为 0 的空数组。")])])]),r._v(" "),t("blockquote",[t("p",[r._v("反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现\nClassCastException 错误。"),t("br"),r._v("\n正例："),t("br"),r._v("\nList<String> list = new ArrayList<>(2);"),t("br"),r._v('\nlist.add("guan");'),t("br"),r._v('\nlist.add("bao");'),t("br"),r._v("\nString[] array = list.toArray(new String[0]);"),t("br"),r._v("\n说明：使用 toArray 带参方法，数组空间大小的 length："),t("br"),r._v("\n1） 等于 0，动态创建与 size 相同的数组，性能最好。"),t("br"),r._v("\n2） 大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。"),t("br"),r._v("\n3） 等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。"),t("br"),r._v("\n4） 大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。")])]),r._v(" "),t("p",[r._v("10.***【强制】*** 在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行\nNPE 判断。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：在 ArrayList#addAll 方法的第一行代码即 Object[] a = c.toArray(); 其中 c 为输入集合参数，如果\n为 null，则直接抛出异常。")])]),r._v(" "),t("p",[r._v("11.***【强制】*** 使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，\n它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配\n器模式，只是转换接口，后台的数据仍是数组。"),t("br"),r._v('\nString[] str = new String[] { "chen", "yang", "hao" };'),t("br"),r._v("\nList list = Arrays.asList(str);"),t("br"),r._v('\n第一种情况：list.add("yangguanbao"); 运行时异常。'),t("br"),r._v('\n第二种情况：str[0] = "change"; 也会随之修改，反之亦然。')])]),r._v(" "),t("p",[r._v("12.***【强制】*** 泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方法，\n而<? super T>不能使用 get 方法，两者在接口调用赋值的场景中容易出错。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：扩展说一下 PECS(Producer Extends Consumer Super)原则："),t("br"),r._v("\n第一、频繁往外读取内容的，适合用\\<? extends T>。"),t("br"),r._v("\n第二、经常往里插入的，适合用<? super T>")])]),r._v(" "),t("p",[r._v("13.***【强制】*** 在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行\ninstanceof 判断，避免抛出 ClassCastException 异常。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：毕竟泛型是在 JDK5 后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。"),t("br"),r._v("\n反例："),t("br"),r._v("\nList<String> generics = null;"),t("br"),r._v("\nList notGenerics = new ArrayList(10);"),t("br"),r._v("\nnotGenerics.add(new Object());"),t("br"),r._v("\nnotGenerics.add(new Integer(1));"),t("br"),r._v("\ngenerics = notGenerics;"),t("br"),r._v("\n// 此处抛出 ClassCastException 异常"),t("br"),r._v("\nString string = generics.get(0);")])]),r._v(" "),t("p",[r._v("14.***【强制】*** 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。")]),r._v(" "),t("blockquote",[t("p",[r._v("正例："),t("br"),r._v("\nList<String> list = new ArrayList<>();"),t("br"),r._v('\nlist.add("1");'),t("br"),r._v('\nlist.add("2");'),t("br"),r._v("\nIterator<String> iterator = list.iterator();"),t("br"),r._v("\nwhile (iterator.hasNext()) {"),t("br"),r._v("\nString item = iterator.next();"),t("br"),r._v("\nif (删除元素的条件) {"),t("br"),r._v("\niterator.remove();"),t("br"),r._v("\n}"),t("br"),r._v("\n}"),t("br"),r._v("\n反例："),t("br"),r._v("\nfor (String item : list) {"),t("br"),r._v('\nif ("1".equals(item)) {'),t("br"),r._v("\nlist.remove(item);"),t("br"),r._v("\n}"),t("br"),r._v("\n}"),t("br"),r._v("\n说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？")])]),r._v(" "),t("p",[r._v("15.***【强制】*** 在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 Arrays.sort，\nCollections.sort 会抛 IllegalArgumentException 异常。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：三个条件如下"),t("br"),r._v("\n1） x，y 的比较结果和 y，x 的比较结果相反。"),t("br"),r._v("\n2） x>y，y>z，则 x>z。"),t("br"),r._v("\n3） x=y，则 x，z 比较结果和 y，z 比较结果相同。"),t("br"),r._v("\n反例：下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中可能会出现异常。"),t("br"),r._v("\nnew Comparator<Student>() {"),t("br"),r._v("\n@Override"),t("br"),r._v("\npublic int compare(Student o1, Student o2) {"),t("br"),r._v("\nreturn o1.getId() > o2.getId() ? 1 : -1;"),t("br"),r._v("\n}"),t("br"),r._v("\n};")])]),r._v(" "),t("p",[r._v("16."),t("strong",[r._v("【推荐】")]),r._v(" 集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：菱形泛型，即 diamond，直接使用<>来指代前边已经指定的类型。"),t("br"),r._v("\n正例："),t("br"),r._v("\n// diamond 方式，即\\<>"),t("br"),r._v("\nHashMap<String, String> userCache = new HashMap<>(16);"),t("br"),r._v("\n// 全省略方式"),t("br"),r._v("\nArrayList<User> users = new ArrayList(10);")])]),r._v(" "),t("p",[r._v("17."),t("strong",[r._v("【推荐】")]),r._v(" 集合初始化时，指定集合初始值大小。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默\n认值（16）即可。"),t("br"),r._v("\n正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认\n为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。"),t("br"),r._v("\n反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，\nresize()方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序\n性能。")])]),r._v(" "),t("p",[r._v("18."),t("strong",[r._v("【推荐】")]),r._v(" 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的\nvalue。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用\nMap.forEach 方法。"),t("br"),r._v("\n正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对\n象；entrySet()返回的是 K-V 值组合集合。")])]),r._v(" "),t("p",[r._v("19."),t("strong",[r._v("【推荐】")]),r._v(" 高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：")]),r._v(" "),t("blockquote",[t("p",[r._v("集合类 Key Value Super 说明"),t("br"),r._v("\nHashtable 不允许为 null 不允许为 null Dictionary 线程安全"),t("br"),r._v("\nConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 锁分段技术（JDK8:CAS）"),t("br"),r._v("\nTreeMap 不允许为 null 允许为 null AbstractMap 线程不安全"),t("br"),r._v("\nHashMap 允许为 null 允许为 null AbstractMap 线程不安全"),t("br"),r._v("\n反例：由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储\nnull 值时会抛出 NPE 异常。")])]),r._v(" "),t("p",[r._v("20."),t("em",[r._v("【参考】")]),r._v(" 合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳\n定性(unorder)带来的负面影响。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。"),t("br"),r._v("\n如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。")])]),r._v(" "),t("p",[r._v("21."),t("em",[r._v("【参考】")]),r._v(" 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的\ncontains()进行遍历去重或者判断包含操作。")])])}),[],!1,null,null,null);t.default=a.exports}}]);