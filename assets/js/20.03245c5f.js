(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{505:function(t,e,s){t.exports=s.p+"assets/img/1690941700405.e7c4d733.png"},506:function(t,e,s){t.exports=s.p+"assets/img/1690941749368.03b42aa8.png"},507:function(t,e,s){t.exports=s.p+"assets/img/1690941775268.e2ab38e9.png"},508:function(t,e,s){t.exports=s.p+"assets/img/1690941813299.57ae4e1f.png"},509:function(t,e,s){t.exports=s.p+"assets/img/1690942650623.5de49ae9.png"},510:function(t,e,s){t.exports=s.p+"assets/img/1690942941960.e3830214.png"},511:function(t,e,s){t.exports=s.p+"assets/img/1690942997506.cdce3ad6.png"},512:function(t,e,s){t.exports=s.p+"assets/img/1690943014790.166929d3.png"},513:function(t,e,s){t.exports=s.p+"assets/img/1690943033975.296b3904.png"},594:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"stream初相识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stream初相识"}},[t._v("#")]),t._v(" Stream初相识")]),t._v(" "),e("p",[t._v("概括讲，可以将Stream流操作分为3种类型：")]),t._v(" "),e("ol",[e("li",[t._v("创建Stream")]),t._v(" "),e("li",[t._v("Stream中间处理")]),t._v(" "),e("li",[t._v("终止Steam\n"),e("img",{attrs:{src:s(505),alt:""}})])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("开始管道\n"),e("img",{attrs:{src:s(506),alt:""}})])]),t._v(" "),e("li",[e("p",[t._v("中间管道\n"),e("img",{attrs:{src:s(507),alt:""}})])]),t._v(" "),e("li",[e("p",[t._v("中间管道\n"),e("img",{attrs:{src:s(508),alt:""}})])])]),t._v(" "),e("h2",{attrs:{id:"stream方法使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stream方法使用"}},[t._v("#")]),t._v(" Stream方法使用")]),t._v(" "),e("h4",{attrs:{id:"map与flatmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map与flatmap"}},[t._v("#")]),t._v(" map与flatMap")]),t._v(" "),e("p",[t._v("map与flatMap都是用于转换已有的元素为其它元素，区别点在于：")]),t._v(" "),e("ul",[e("li",[t._v("map 必须是一对一的，即每个元素都只能转换为1个新的元素")]),t._v(" "),e("li",[t._v("flatMap 可以是一对多的，即每个元素都可以转换为1个或者多个新的元素")])]),t._v(" "),e("p",[t._v("比如：有一个字符串ID列表，现在需要将其转为User对象列表。可以使用map来实现：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('/**\n * 演示map的用途：一对一转换\n */\npublic void stringToIntMap() {\n    List<String> ids = Arrays.asList("205", "105", "308", "469", "627", "193", "111");\n    // 使用流操作\n    List<User> results = ids.stream()\n            .map(id -> {\n                User user = new User();\n                user.setId(id);\n                return user;\n            })\n            .collect(Collectors.toList());\n    System.out.println(results);\n}\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n[User{id='205'}, \n User{id='105'},\n User{id='308'}, \n User{id='469'}, \n User{id='627'}, \n User{id='193'}, \n User{id='111'}]\n\n\n")])])]),e("p",[t._v("现有一个句子列表，需要将句子中每个单词都提取出来得到一个所有单词列表。这种情况用map就搞不定了，需要flatMap上场了：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public void stringToIntFlatmap() {\n    List<String> sentences = Arrays.asList("hello world","Jia Gou Wu Dao");\n    // 使用流操作\n    List<String> results = sentences.stream()\n            .flatMap(sentence -> Arrays.stream(sentence.split(" ")))\n            .collect(Collectors.toList());\n    System.out.println(results);\n}\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n[hello, world, Jia, Gou, Wu, Dao]\n\n\n")])])]),e("h4",{attrs:{id:"peek和foreach方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#peek和foreach方法"}},[t._v("#")]),t._v(" peek和foreach方法")]),t._v(" "),e("p",[t._v("peek和foreach，都可以用于对元素进行遍历然后逐个的进行处理。\n但根据前面的介绍，peek属于中间方法，而foreach属于终止方法。这也就意味着peek只能作为管道中途的一个处理步骤，而没法直接执行得到结果，其后面必须还要有其它终止操作的时候才会被执行；而foreach作为无返回值的终止方法，则可以直接执行相关操作。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public void testPeekAndforeach() {\n    List<String> sentences = Arrays.asList("hello world","Jia Gou Wu Dao");\n    // 演示点1： 仅peek操作，最终不会执行\n    System.out.println("----before peek----");\n    sentences.stream().peek(sentence -> System.out.println(sentence));\n    System.out.println("----after peek----");\n    // 演示点2： 仅foreach操作，最终会执行\n    System.out.println("----before foreach----");\n    sentences.stream().forEach(sentence -> System.out.println(sentence));\n    System.out.println("----after foreach----");\n    // 演示点3： peek操作后面增加终止操作，peek会执行\n    System.out.println("----before peek and count----");\n    sentences.stream().peek(sentence -> System.out.println(sentence)).count();\n    System.out.println("----after peek and count----");\n}\n\n')])])]),e("p",[t._v("输出结果可以看出，peek独自调用时并没有被执行、但peek后面加上终止操作之后便可以被执行，而foreach可以直接被执行：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("----before peek----\n----after peek----\n----before foreach----\nhello world\nJia Gou Wu Dao\n----after foreach----\n----before peek and count----\nhello world\nJia Gou Wu Dao\n----after peek and count----\n")])])]),e("h4",{attrs:{id:"filter、sorted、distinct、limit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#filter、sorted、distinct、limit"}},[t._v("#")]),t._v(" filter、sorted、distinct、limit")]),t._v(" "),e("p",[t._v("这几个都是常用的Stream的中间操作方法，具体的方法的含义在上面的表格里面有说明。具体使用的时候，可以根据需要选择一个或者多个进行组合使用，或者同时使用多个相同方法的组合：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\npublic void testGetTargetUsers() {\n    List<String> ids = Arrays.asList("205","10","308","49","627","193","111", "193");\n    // 使用流操作\n    List<Dept> results = ids.stream()\n            .filter(s -> s.length() > 2)\n            .distinct()\n            .map(Integer::valueOf)\n            .sorted(Comparator.comparingInt(o -> o))\n            .limit(3)\n            .map(id -> new Dept(id))\n            .collect(Collectors.toList());\n    System.out.println(results);\n}\n\n\n')])])]),e("p",[t._v("上面的代码片段的处理逻辑很清晰：")]),t._v(" "),e("ol",[e("li",[t._v("使用filter过滤掉不符合条件的数据")]),t._v(" "),e("li",[t._v("通过distinct对存量元素进行去重操作")]),t._v(" "),e("li",[t._v("通过map操作将字符串转成整数类型")]),t._v(" "),e("li",[t._v("借助sorted指定按照数字大小正序排列")]),t._v(" "),e("li",[t._v("使用limit截取排在前3位的元素")]),t._v(" "),e("li",[t._v("又一次使用map将id转为Dept对象类型")]),t._v(" "),e("li",[t._v("使用collect终止操作将最终处理后的数据收集到list中")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[Dept{id=111},  Dept{id=193},  Dept{id=205}]\n")])])]),e("h4",{attrs:{id:"简单结果终止方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单结果终止方法"}},[t._v("#")]),t._v(" 简单结果终止方法")]),t._v(" "),e("p",[t._v("按照前面介绍的，终止方法里面像count、max、min、findAny、findFirst、anyMatch、allMatch、nonneMatch等方法，均属于这里说的简单结果终止方法。所谓简单，指的是其结果形式是数字、布尔值或者Optional对象值等。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\npublic void testSimpleStopOptions() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    // 统计stream操作后剩余的元素个数\n    System.out.println(ids.stream().filter(s -> s.length() > 2).count());\n    // 判断是否有元素值等于205\n    System.out.println(ids.stream().filter(s -> s.length() > 2).anyMatch("205"::equals));\n    // findFirst操作\n    ids.stream().filter(s -> s.length() > 2)\n            .findFirst()\n            .ifPresent(s -> System.out.println("findFirst:" + s));\n}\n\n\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n6\ntrue\nfindFirst:205\n\n\n")])])]),e("p",[e("strong",[t._v("避坑提醒")]),t._v("\n这里需要补充提醒下，一旦一个Stream被执行了终止操作之后，后续便不可以再读这个流执行其他的操作了，否则会报错")]),t._v(" "),e("h2",{attrs:{id:"collector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collector"}},[t._v("#")]),t._v(" Collector")]),t._v(" "),e("h4",{attrs:{id:"collect-collector-collectors区别与关联"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collect-collector-collectors区别与关联"}},[t._v("#")]),t._v(" collect\\Collector\\Collectors区别与关联")]),t._v(" "),e("ol",[e("li",[t._v("collect是Stream流的一个终止方法，会使用传入的收集器（入参）对结果执行相关的操作，这个收集器必须是Collector接口的某个具体实现类")]),t._v(" "),e("li",[t._v("Collector是一个接口，collect方法的收集器是Collector接口的具体实现类")]),t._v(" "),e("li",[t._v("Collectors是一个工具类，提供了很多的静态工厂方法，提供了很多Collector接口的具体实现类，是为了方便程序员使用而预置的一些较为通用的收集器（如果不使用Collectors类，而是自己去实现Collector接口，也可以）。")])]),t._v(" "),e("h4",{attrs:{id:"collector使用与剖析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collector使用与剖析"}},[t._v("#")]),t._v(" Collector使用与剖析")]),t._v(" "),e("p",[t._v("Stream结果收集操作的本质，其实就是将Stream中的元素通过收集器定义的函数处理逻辑进行加工，然后输出加工后的结果。")]),t._v(" "),e("p",[t._v("根据其执行的操作类型来划分，又可将收集器分为几种不同的大类：\n"),e("img",{attrs:{src:s(509),alt:""}})]),t._v(" "),e("h4",{attrs:{id:"恒等处理collector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#恒等处理collector"}},[t._v("#")]),t._v(" 恒等处理Collector")]),t._v(" "),e("p",[t._v("所谓恒等处理，指的就是Stream的元素在经过Collector函数处理前后完全不变，例如toList()操作，只是最终将结果从Stream中取出放入到List对象中，并没有对元素本身做任何的更改处理：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list.stream().collect(Collectors.toList());\nlist.stream().collect(Collectors.toSet());\nlist.stream().collect(Collectors.toCollection());\n\n")])])]),e("h4",{attrs:{id:"归约汇总collector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#归约汇总collector"}},[t._v("#")]),t._v(" 归约汇总Collector")]),t._v(" "),e("p",[t._v("对于归约汇总类的操作，Stream流中的元素逐个遍历，进入到Collector处理函数中，然后会与上一个元素的处理结果进行合并处理，并得到一个新的结果，以此类推，直到遍历完成后，输出最终的结果。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public void calculateSum() {\n    Integer salarySum = getAllEmployees().stream()\n            .filter(employee -> "上海公司".equals(employee.getSubCompany()))\n            .collect(Collectors.summingInt(Employee::getSalary));\n    System.out.println(salarySum);\n}\n\n')])])]),e("h4",{attrs:{id:"分组分区collector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分组分区collector"}},[t._v("#")]),t._v(" 分组分区Collector")]),t._v(" "),e("p",[t._v("Collectors工具类中提供了groupingBy方法用来得到一个分组操作Collector")]),t._v(" "),e("p",[t._v("groupingBy()操作需要指定两个关键输入，即分组函数和值收集器：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("分组函数：一个处理函数，用于基于指定的元素进行处理，返回一个用于分组的值（即分组结果HashMap的Key值），对于经过此函数处理后返回值相同的元素，将被分配到同一个组里。")])]),t._v(" "),e("li",[e("p",[t._v("值收集器：对于分组后的数据元素的进一步处理转换逻辑，此处还是一个常规的Collector收集器，和collect()方法中传入的收集器完全等同（可以想想俄罗斯套娃，一个概念）")])])]),t._v(" "),e("h4",{attrs:{id:"collector的叠加嵌套"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collector的叠加嵌套"}},[t._v("#")]),t._v(" Collector的叠加嵌套")]),t._v(" "),e("p",[t._v("有的时候，我们需要根据先根据某个维度进行分组后，再根据第二维度进一步的分组，然后再对分组后的结果进一步的处理操作，这种场景里面，我们就可以通过Collector收集器的叠加嵌套使用来实现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public void groupByCompanyAndDepartment() {\n    // 按照子公司+部门双层维度，统计各个部门内的人员数\n    Map<String, Map<String, Long>> resultMap = getAllEmployees().stream()\n            .collect(Collectors.groupingBy(Employee::getSubCompany,\n                    Collectors.groupingBy(Employee::getDepartment,\n                            Collectors.counting())));\n    System.out.println(resultMap);\n}\n\n")])])]),e("h4",{attrs:{id:"collectors提供的收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collectors提供的收集器"}},[t._v("#")]),t._v(" Collectors提供的收集器")]),t._v(" "),e("p",[e("img",{attrs:{src:s(510),alt:""}})]),t._v(" "),e("h4",{attrs:{id:"collector接口介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collector接口介绍"}},[t._v("#")]),t._v(" Collector接口介绍")]),t._v(" "),e("p",[t._v("所谓的收集器，其实就是一个Collector接口的具体实现类。所以如果想要定制自己的收集器，首先要先了解Collector接口到底有哪些方法需要我们去实现，以及各个方法的作用与用途。\n当我们新建一个MyCollector类并声明实现Collector接口的时候，会发现需要我们实现5个接口：\n"),e("img",{attrs:{src:s(511),alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:s(512),alt:""}}),t._v("\n对于characteristics返回set集合中的可选值，说明如下：\n"),e("img",{attrs:{src:s(513),alt:""}})])])}),[],!1,null,null,null);e.default=r.exports}}]);