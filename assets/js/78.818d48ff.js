(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{487:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"_1-reentrantlock的介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-reentrantlock的介绍"}},[e._v("#")]),e._v(" 1. ReentrantLock的介绍")]),e._v(" "),n("p",[e._v("Java中提供的锁: synchronized, lock锁")]),e._v(" "),n("p",[e._v("ReentrantLock就是一个互斥锁,可以让多线程执行期间,只有一个线程在执行指定一段代码")]),e._v(" "),n("p",[e._v("使用实例:")]),e._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Main")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ReentrantLock")]),e._v(" lock "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ReentrantLock")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//加锁")]),e._v("\n        lock"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("lock")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("try")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//执行业务")]),e._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("finally")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//施放锁")]),e._v("\n            lock"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("unlock")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("h2",{attrs:{id:"_2-reentrantlock的lock方法源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-reentrantlock的lock方法源码"}},[e._v("#")]),e._v(" 2. ReentrantLock的lock方法源码")]),e._v(" "),n("h3",{attrs:{id:"_2-1-lock方法简单分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-lock方法简单分析"}},[e._v("#")]),e._v(" 2.1 lock方法简单分析")]),e._v(" "),n("p",[e._v("在进入到lock方法后,发现内部调用了sync.lock()方法,去找方法的实现时,发现了两个实现")]),e._v(" "),n("ul",[n("li",[e._v("FairSync: 公平锁"),n("br"),e._v("\n每个线程都会在执行lock方法时,会先查看是否有线程排队,如果有,直接去排队.如果没有才回去尝试竞争一下锁资源")]),e._v(" "),n("li",[e._v("NonfairSync: 非公平锁"),n("br"),e._v("\n每个线程都会在执行lock方法时,先尝试获取锁资源,获取不到再排队")])]),e._v(" "),n("p",[e._v("如果需要使用公平锁: 在new ReentrantLock是,传入参数true"),n("br"),e._v("\n如果需要使用非公平锁: 直接无参构造器.")]),e._v(" "),n("p",[e._v("ps: 更推荐使用非公平锁,非公平锁的效率比公平锁高")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n")])])]),n("p",[e._v("从源码的角度也发现了公平锁直接调用acquire()方法获取锁,而非公平锁会先基于CAS的方式尝试获取锁资源,如果获取不到,才会执行acquire()方法")]),e._v(" "),n("h3",{attrs:{id:"_2-2-分析aqs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-分析aqs"}},[e._v("#")]),e._v(" 2.2 分析AQS")]),e._v(" "),n("p",[e._v("AQS就是AbstractQueuedSynchronizer,AQS内部维护这一个队列"),n("br"),e._v("\n还有三个核心属性: state, head, tail\n"),n("a",{attrs:{title:"",href:"https://gj-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/2022-09-19-5qV4nc.png"}},[n("img",{attrs:{src:"https://gj-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/2022-09-19-5qV4nc.png",alt:""}})])]),e._v(" "),n("h3",{attrs:{id:"_2-3-lock方法源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-lock方法源码"}},[e._v("#")]),e._v(" 2.3 lock方法源码")]),e._v(" "),n("p",[e._v("非公平锁的lock方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final void lock() {\n    // 以CAS的方式,尝试将state从0改为1\n    if (compareAndSetState(0, 1))\n        // 证明修改state成功,也就代表获取锁资源成功\n        // 将当前线程设置到AQS中的exclusiveOwnerThread(AQS中),代表当前线程拿着锁资源(和后面的可重入锁有关系)\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n")])])]),n("p",[e._v("公平锁的lock方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final void lock() {\n    acquire(1);\n}\n")])])]),n("h2",{attrs:{id:"_3-reentrantlock的acquire方法源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-reentrantlock的acquire方法源码"}},[e._v("#")]),e._v(" 3. ReentrantLock的acquire方法源码")]),e._v(" "),n("p",[e._v("公平锁还是非公平锁都会调用当前方法的acquire方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public final void acquire(int arg) {\n    // tryAquire方法,分为两种实现. 第一种是公平锁,第二种是非公平锁\n    // 公平锁操作: 如果state是0,再看是否有线程排队,如果有我就去排队.如果是锁重入的操作,直接获取锁\n    // 非公平锁操作: 如果state是0,直接尝试CAS修改.如果是锁重入的操作,直接获取锁\n    if (!tryAcquire(arg) &&\n        // addWaiter方法,在线程没有通过tryAcquire拿到锁资源时,需要将当前线程封装为Node对象,去AQS内部排队\n        // acquireQueued方法, 查看当前线程是否排在队伍前面,如果是就尝试获取锁资源.如果长时间没获取锁,也需要将当前线程挂起\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n")])])]),n("h2",{attrs:{id:"_4-reentrantlock的tryacquire方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-reentrantlock的tryacquire方法"}},[e._v("#")]),e._v(" 4. ReentrantLock的tryAcquire方法")]),e._v(" "),n("p",[e._v("tryAcquire方法是AQS提供的,内部并没有任何的实现,需要继承AQS的类去实现代码逻辑"),n("br"),e._v("\ntryAcquire在ReentrantLock中提供了两种实现: 公平锁, 非公平锁")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 非公平锁实现\nfinal boolean nonfairTryAcquire(int acquires) {\n    // 拿到了当前线程\n    final Thread current = Thread.currentThread();\n    // 拿到AQS的state值\n    int c = getState();\n    如果state为0, 这就代表当前没有线程占用锁资源\n    if (c == 0) {\n        // 直接基于CAS的方式,尝试修改state,从0-1,如果成功就代码拿到锁资源\n        if (compareAndSetState(0, acquires)) {\n            // 将exclusiveOwnerThread属性设置为当前线程\n            setExclusiveOwnerThread(current);\n            // 返回true\n            return true;\n        }\n    }\n    // 说明state肯定不为0, 不为0就代表当前lock被线程占用\n    // 判断占用锁资源的线程是不是当前线程\n    else if (current == getExclusiveOwnerThread()) {\n        // 锁重入操作\n        // 对state + 1\n        int nextc = c + acquires;\n        // 判断锁重入是否已经达到最大值\n        if (nextc < 0) // overflow\n            throw new Error("Maximum lock count exceeded");\n        将AQS的state设置为新值    \n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 公平锁实现\nprotected final boolean tryAcquire(int acquires) {\n    // 获取当前线程\n    final Thread current = Thread.currentThread();\n    // 获取state\n    int c = getState();\n    // 没有线程占用锁资源\n    if (c == 0) {\n        // 首先查看,有没有线程排队\n        if (!hasQueuedPredecessors() &&\n            // 如果没有线程排队, CAS尝试获取锁资源\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n')])])]),n("p",[e._v("公平锁和非公平锁的tryAcquire方法的唯一区别就是,当判断state为0之后.")]),e._v(" "),n("ul",[n("li",[e._v("公平锁会先查看是否有线程正在排队,如果有,直接返回false,如果没有线程排队,执行CAS尝试获取锁资源")]),e._v(" "),n("li",[e._v("非公平锁不管有没有线程排队,直接以CAS的方式尝试获取锁资源")])]),e._v(" "),n("h2",{attrs:{id:"_5-reentrantlock的addwaiter方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-reentrantlock的addwaiter方法"}},[e._v("#")]),e._v(" 5. ReentrantLock的addWaiter方法")]),e._v(" "),n("p",[e._v("在线程执行tryAcquire方法没有获取到锁资源之后,会返回false,再配置上if中的!操作,会执行&&后面的方法,而在acquireQueued(addWaiter(Node.EXCLUSIVE), arg))的参数中执行了addWaiter,要将当前获取锁失败的线程封装成Node,排队的AQS队列中.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 获取锁失败,封装Node,排队的AQS队列中\nprivate Node addWaiter(Node mode) {\n    // 将线程封装为Node对象\n    Node node = new Node(Thread.currentThread(), mode);\n    // 获取到tail节点 pred\n    Node pred = tail;\n    // 如果tail节点不为null\n    if (pred != null) {\n        // 将当前节点的prev,执行tail\n        node.prev = pred;\n        // 为了避免并发问题,以CAS的方式将tail指向当前线程\n        if (compareAndSetTail(pred, node)) {\n            // 将之前的tail的next,指向当前节点\n            pred.next = node;\n            // 返回当前节点\n            return node;\n        }\n    }\n    // 如果在队列为空,或者CAS操作失败后,会执行end方法,将当前node排到队列的队尾\n    enq(node);\n    return node;\n}\n")])])]),n("p",[e._v("end方法,传入的node就是当前节点")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private Node enq(final Node node) {\n    // 死循环\n    for (;;) {\n        // 获取tail节点\n        Node t = tail;\n        if (t == null) { // Must initialize\n            // 如果队列为空,先初始化head节点,作为头\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            // 导致,队列肯定不为空,采用之前的逻辑,将当前节点插入到队列的末尾作为tail,循环到插入成功为止.\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n")])])]),n("p",[e._v("整体逻辑为先初始化Node节点,当当前线程传入,并且表示为互斥锁.\n尝试将当前Node插入的AQS队列的末尾")]),e._v(" "),n("ul",[n("li",[e._v("队列为空: 执行end,先初始化空Node作为头,然后再将当前Node插入,作为tail")]),e._v(" "),n("li",[e._v("队列不为空: 直接将当前Node插入,作为tail")])]),e._v(" "),n("h2",{attrs:{id:"_6-reentrantlock的acquirequeued方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-reentrantlock的acquirequeued方法"}},[e._v("#")]),e._v(" 6. ReentrantLock的acquireQueued方法")]),e._v(" "),n("p",[e._v("首先查看当前node是否排在队列的第一个位置(不算head),直接再次执行tryAquire方法竞争锁资源,否则尝试将当前线程挂起,最终排在有效节点后,才回将当前线程挂机")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 队伍前面,竞争锁资源.队伍非前面,挂起线程\nfinal boolean acquireQueued(final Node node, int arg) {\n    // 竞争锁资源失败\n    boolean failed = true;\n    try {\n        // 线程中断标识\n        boolean interrupted = false;\n        // 死循环\n        for (;;) {\n            // predecessor就是获取当前节点的上一个节点\n            final Node p = node.predecessor();\n            // 如果当前节点的上一个节点是head,就执行tryAcquire方法,竞争锁资源\n            if (p == head && tryAcquire(arg)) {\n                // 竞争锁资源成功, 进入当前业务代码\n                // 因为当前线程已经拿到锁资源,将当前线程的Node设置为head,并且将Node中的prev和thread设为null\n                setHead(node);\n                // 将之前的头节点的next设置为null,让GC将之前的head回收掉\n                p.next = null; // help GC\n                // 将获取锁失败的标识设置为false\n                failed = false;\n                // 返回线程中断标识,默认情况为false\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n")])])]),n("p",[e._v("shouldParkAfterFailedAcquire()方法,判断当前线程是否可以挂起")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    // 拿到了上一个节点的状态\n    int ws = pred.waitStatus;\n    // 如果ws为-1,直接返回true,当前节点可以挂起线程\n    if (ws == Node.SIGNAL)\n        return true;\n    // 如果ws > 0, 说明肯定是CANCELLED状态,绕过这个节点,找上一个节点\n    if (ws > 0) {\n        // 循环,直到找到上一个节点为小于等于0的节点\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        // 可能为0, -2, -3 直接以CAS的方式将节点状态改为-1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n")])])]),n("p",[e._v("parkAndCheckInterrupt()方法, 将当前线程挂起")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 找到上一个节点状态是正常为-1的后,就可以调用当前方法将线程挂起\nprivate final boolean parkAndCheckInterrupt() {\n    // 直接使用Unsafe类的park方法挂起线程\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n")])])]),n("h2",{attrs:{id:"_7-reentrantlock的unlock方法源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-reentrantlock的unlock方法源码"}},[e._v("#")]),e._v(" 7. ReentrantLock的unlock方法源码")]),e._v(" "),n("p",[e._v("unlock释放锁操作不分为公平和非公平,都是执行sync的release方法"),n("br"),e._v("\n释放锁的核心,就是将state从大于0的数值更改为0即为释放锁成功,并且unlock方法应该会涉及到将AQS队列中阻塞的线程进行唤醒,阻塞用的是park方法,唤醒必然是unpark方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public void unlock() {\n    // 每次只释放1\n    sync.release(1);\n}\n")])])]),n("h2",{attrs:{id:"_8-reentrantlock的release方法源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-reentrantlock的release方法源码"}},[e._v("#")]),e._v(" 8. ReentrantLock的release方法源码")]),e._v(" "),n("p",[e._v("在释放锁时,只有state被减为0之后,才会去唤醒AQS队列中被挂起的线程"),n("br"),e._v("\n在唤醒挂起线程时,如果head的next状态不正确,会从后往前找离head最近的节点进行唤醒"),n("br"),e._v("\n为什么从后往前找? 因为addWaiter是先将prev指针赋值,最后才回将上一个节点的next指针赋值,为了避免丢失节点或者跳过节点,必须从后往前找!")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 释放锁操作\npublic final boolean release(int arg) {\n    // 先查看tryRelease方法\n    if (tryRelease(arg)) {\n        // 释放锁成功,进行后续处理\n        Node h = head;\n        // 如果head不为null,并且当前head的状态不为0\n        if (h != null && h.waitStatus != 0)\n            // 说明AQS的队列中,有Node在排队,并且线程已经挂起来\n            // 需要唤醒被挂起的Node\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n")])])]),n("p",[e._v("tryRelease()方法,释放锁")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected final boolean tryRelease(int releases) {\n    // 直接获取锁的线程,并且-releases,将state-1\n    int c = getState() - releases;\n    // 如果释放锁的线程,不是占用锁的线程,直接抛出异常\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    // 声明了一个标识    \n    boolean free = false;\n    // 判断state-1后是否为0\n    if (c == 0) {\n        // 如果为0,锁资源释放掉了\n        free = true;\n        // 将占用互斥锁的线程设置为null\n        setExclusiveOwnerThread(null);\n    }\n    // 锁之前重入了,一次没释放掉,将c赋值个state,等待下次再次执行时,再次判断\n    setState(c);\n    return free;\n}\n")])])]),n("p",[e._v("unparkSuccessor()方法,唤醒AQS中被挂起的线程")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private void unparkSuccessor(Node node) {\n    // 获取head的状态\n    int ws = node.waitStatus;\n    if (ws < 0)\n        // 将当前head的状态设置为0\n        compareAndSetWaitStatus(node, ws, 0);\n    // 拿到next节点    \n    Node s = node.next;\n    // 如果下一个节点为null,或者状态未CANCEL,需要找到里head节点最近的有效Node\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        // 从后往前找这个节点(为什么从后往前找,需要查看addWaiter的内容)\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    // 找到最近的node后,直接唤醒\n    if (s != null)\n        // 唤醒线程\n        LockSupport.unpark(s.thread);\n}\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);