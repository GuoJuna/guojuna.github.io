(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{512:function(a,t,v){"use strict";v.r(t);var _=v(0),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"索引是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引是什么"}},[a._v("#")]),a._v(" 索引是什么?")]),a._v(" "),t("p",[a._v("数据库索引，是帮助Mysql高效获取数据的排好序的数据结构，它能加快数据库的查询速度。")]),a._v(" "),t("h2",{attrs:{id:"存储引擎是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储引擎是什么"}},[a._v("#")]),a._v(" 存储引擎是什么")]),a._v(" "),t("p",[a._v("不同的数据文件在磁盘的不同组织形式")]),a._v(" "),t("h2",{attrs:{id:"索引数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引数据结构"}},[a._v("#")]),a._v(" 索引数据结构")]),a._v(" "),t("ul",[t("li",[a._v("二叉树")]),a._v(" "),t("li",[a._v("红黑树")]),a._v(" "),t("li",[a._v("Hash表")]),a._v(" "),t("li",[a._v("B-Tree(多叉平衡树)")])]),a._v(" "),t("h2",{attrs:{id:"hash表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash表"}},[a._v("#")]),a._v(" Hash表")]),a._v(" "),t("ul",[t("li",[a._v("查找可以直接根据key访问")]),a._v(" "),t("li",[a._v("不能进行范围查找 select * form t where t.col2 > 89")])]),a._v(" "),t("h2",{attrs:{id:"b-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-tree"}},[a._v("#")]),a._v(" B-Tree")]),a._v(" "),t("ul",[t("li",[a._v("叶节点具有相同的深度, 叶节点的指针为空")]),a._v(" "),t("li",[a._v("所有索引元素不重复")]),a._v(" "),t("li",[a._v("节点中的数据索引从左到右递增排序")])]),a._v(" "),t("p",[a._v("##B+Tree")]),a._v(" "),t("ul",[t("li",[a._v("非叶子节点不存储data, 只存储索引,可以放更多的索引")]),a._v(" "),t("li",[a._v("叶子节点包含所有索引字段")]),a._v(" "),t("li",[a._v("叶子节点用指针连接, 提高区间访问的性能")])]),a._v(" "),t("h2",{attrs:{id:"相对b树-b-树做索引的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相对b树-b-树做索引的优势"}},[a._v("#")]),a._v(" 相对B树，B+树做索引的优势")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("B+树的磁盘IO代价更低：B+树非叶子节点没有指向数据行的指针，所以相同的磁盘容量存储的节点数更多，相应的IO读写次数肯定减少了。")])]),a._v(" "),t("li",[t("p",[a._v("B+树的查询效率更加稳定：由于所有数据都存于叶子节点。所有关键字查询的路径长度相同，每一个数据的查询效率相当。")])]),a._v(" "),t("li",[t("p",[a._v("所有的叶子节点形成了一个有序链表，更加便于查找。")])])]),a._v(" "),t("h2",{attrs:{id:"myisam索引和innodb索引的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#myisam索引和innodb索引的区别"}},[a._v("#")]),a._v(" MyISAM索引和Innodb索引的区别")]),a._v(" "),t("p",[a._v("MyISAM使用B+树作为索引结构，叶节点叶节点的data域保存的是存储数据的地址，主键索引key值唯一，辅助索引key可以重复，二者在结构上相同。")]),a._v(" "),t("p",[a._v("因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果要找的Key存在，则取出其data域的值，然后以data域的值为地址，去读取相应数据记录 。因此，索引文件和数据文件是分开的，从索引中检索到的是数据的地址，而不是数据。")]),a._v(" "),t("p",[a._v("Innodb也是用B+树作为索引结构，但具体实现方式却与MyISAM截然不同，首先，数据表本身就是按照b+树组织，所以数据文件本身就是主键索引文件。叶节点key值为数据表的主键，data域为完整的数据记录。")]),a._v(" "),t("p",[a._v("因此InnoDB表数据文件本身就是主键索引(这也就是MyISAM可以允许没有主键，但是Innodb必须有主键的原因）。第二个与MyISAM索引的不同是InnoDB的辅助索引的data域存储相应数据记录的主键值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。")]),a._v(" "),t("h2",{attrs:{id:"索引类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引类型"}},[a._v("#")]),a._v(" 索引类型")]),a._v(" "),t("p",[a._v("普通索引：（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。")]),a._v(" "),t("p",[a._v("唯一索引：普通索引允许被索引的数据列包含重复的值，而唯一索引不允许，但是可以为null。所以任务是保证访问速度和避免数据出现重复。")]),a._v(" "),t("p",[a._v("主键索引：在主键字段创建的索引，一张表只有一个主键索引。")]),a._v(" "),t("p",[a._v("组合索引：多列值组成一个索引，专门用于组合搜索。")]),a._v(" "),t("p",[a._v("全文索引：对文本的内容进行分词，进行搜索。（MySQL5.6及以后的版本，MyISAM和InnoDB存储引擎均支持全文索引。")])])}),[],!1,null,null,null);t.default=s.exports}}]);