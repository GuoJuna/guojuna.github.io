(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{450:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"dockerfile-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile-简介"}},[e._v("#")]),e._v(" Dockerfile 简介")]),e._v(" "),t("p",[e._v("dockerfile 可以理解为一个制作镜像的脚本，但远没有脚本复杂。他根据某种格式自定义内容，\n就可以快速创建出需求的镜像。")]),e._v(" "),t("h2",{attrs:{id:"dockerfile-文件格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile-文件格式"}},[e._v("#")]),e._v(" Dockerfile 文件格式")]),e._v(" "),t("p",[e._v("Dockerfile文件格式如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('##  Dockerfile文件格式\n\n# This dockerfile uses the ubuntu image\n# VERSION 2 - EDITION 1\n# Author: docker_user\n# Command format: Instruction [arguments / command] ..\n \n# 1、第一行必须指定 基础镜像信息\nFROM ubuntu\n \n# 2、维护者信息\nMAINTAINER docker_user docker_user@email.com\n \n# 3、镜像操作指令\nRUN echo "deb https://archive.ubuntu.com/ubuntu/ raring main universe" >> /etc/apt/sources.list\nRUN apt-get update && apt-get install -y nginx\nRUN echo "\\ndaemon off;" >> /etc/nginx/nginx.conf\n \n# 4、容器启动执行指令\nCMD /usr/sbin/nginx\n')])])]),t("h2",{attrs:{id:"指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[e._v("#")]),e._v(" 指令")]),e._v(" "),t("ol",[t("li",[e._v("FROM：底层镜像（如系统）")])]),e._v(" "),t("blockquote",[t("p",[e._v("这个 FROM 指令是 dockerfile 的第一个指令，指定了基础镜像，后面的所有指令都是运行在该\n基础镜像环境上的 MAINTAINER，该指令是描述的维护者信息。\n底层的系统镜像用的是什么，使用 from 指定，绝大部分情况都用的底层有个系统或者基础的环\n境用的是什么，对 docker 不熟练使用 centos 镜像即可。")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("RUN：构建时容器内运行的命令")])]),e._v(" "),t("blockquote",[t("p",[e._v("RUN 指令用于在容器中执行命令。我们常用来安装基础软件。\n镜像安装软件依赖包都可以放在 RUN 中")])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("COPY：复制 docker 目录中的文件到镜像中")])]),e._v(" "),t("blockquote",[t("p",[e._v("COPY 指令类似 ADD 指令，但是 ADD 指令范围更广些，ADD 能够自动解压文件，能够访问网\n络资源，而 COPY 指令做不到。\n非目录需要重新指定，放在目录中非常便利，属于好的一种习惯，值得推荐使用目录。")])]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("ADD：复制 docker 目录中的文件到镜像中。（过程可以解压）")])]),e._v(" "),t("blockquote",[t("p",[e._v("ADD 指令是用来将宿主机某个文件或目录放到（复制）容器某个目录下面。\n官方不推荐 ADD,高级复制功能，需求不精准，推荐使用 COPY。")])]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("EXPOSE：声明开放端口")])]),e._v(" "),t("blockquote",[t("p",[e._v("EXPOSE 指令用于暴露容器里的端口，我们在 3.5 里面演示过了，nginx 暴露的端口是 80，但\n是启动容器的时候需要指定宿主机端口来映射暴露的端口。需要暴露多个端口的话可以使用多\n个 EXPOSE，也可以一个 EXPOSE 指令后面跟多个端口，端口之间用空格隔开。\n声明不是变更，变更使用-p 构建容器时候使用。")])]),e._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[e._v("ENV：设置环境变量")])]),e._v(" "),t("blockquote",[t("p",[e._v("ENV 指令是用于设置环境变量的。\n底层环境变量需要需提前设置。")])]),e._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[e._v("CMD：容器启动时执行的命令，最多只能执行一条")])]),e._v(" "),t("blockquote",[t("p",[e._v("CMD 指令是你在容器启动的时候帮你运行的命令，而 RUN 这个指令是构建镜像的时候帮你运\n行的命令。\n容器启动时执行命令，最多执行一条。")])]),e._v(" "),t("ol",{attrs:{start:"8"}},[t("li",[e._v("WORKDIR：声明工作目录。类似 cd")])]),e._v(" "),t("blockquote",[t("p",[e._v("WORKDIR 是指下面的指令都在 WORKDIR 指定目录下面工作，这个与 linux 里面的 cd 差不\n多。\n切换目录使用 WORKDIR。\n做容器轻量级最好，比较小就很好，使用一条命令就不要使用两条命令。")])]),e._v(" "),t("h2",{attrs:{id:"构建镜像"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构建镜像"}},[e._v("#")]),e._v(" 构建镜像")]),e._v(" "),t("p",[e._v("docker build 命令会根据 Dockerfile 文件及上下文构建新 Docker 镜像。构建上下文是指 Dockerfile 所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。")]),e._v(" "),t("p",[e._v("将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker build .\nSending build context to Docker daemon  6.51 MB\n...\n")])])]),t("p",[e._v("Dockerfile 一般位于构建上下文的根目录下，也可以通过-f指定该文件的位置")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker build -f /path/to/a/Dockerfile .\n")])])]),t("p",[e._v("构建时，还可以通过-t参数指定构建成镜像的仓库、标签。")]),e._v(" "),t("h2",{attrs:{id:"镜像标签"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#镜像标签"}},[e._v("#")]),e._v(" 镜像标签")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker build -t nginx/v3 .\n")])])]),t("p",[e._v("如果存在多个仓库下，或使用多个镜像标签，就可以使用多个-t参数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docker build -t nginx/v3:1.0.2 -t nginx/v3:latest .\n")])])]),t("h2",{attrs:{id:"简单示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单示例"}},[e._v("#")]),e._v(" 简单示例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# 1.创建Dockerfile文件\nmkdir mynginx\ncd mynginx\nvi Dockerfile\n\n# 2.添加Dockerfile文件内容,这个 Dockerfile 很简单，一共就两行涉及到了两条指令：FROM 和 RUN，FROM 表示获取指定基础镜像，RUN 执行命令，在执行的过程中重写了 nginx 的默认页面信息，将信息替换为：Hello, Docker!\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html\n\n# 3.执行Dockerfile文件, 命令最后有一个. 表示当前目录\ndocker build -t nginx:v1 .\n\n# 4.构建完成后,查看所有镜像，如果存在 REPOSITORY 为 nginx 和 TAG 是 v1 的信息，就表示构建成功\ndocker images\n\n# 5.启动容器, 用 nginx 镜像启动一个容器，命名为docker_nginx_v1，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器\ndocker run  --name docker_nginx_v1   -d -p 80:80 nginx:v1\n\n# 6.修改容器内容, 容器启动后，需要对容器内的文件进行进一步的完善，可以使用docker exec -it xx bash命令再次进行修改\ndocker exec -it docker_nginx_v1   bash\nroot@3729b97e8226:/# echo '<h1>Hello, Docker neo!</h1>' > /usr/share/nginx/html/index.html\nroot@3729b97e8226:/# exit\nexit\n\n# 7.修改了容器的文件，也就是改动了容器的存储层，可以通过 docker diff 命令看到具体的改动\ndocker diff docker_nginx_v1 \n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);