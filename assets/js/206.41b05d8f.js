(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{615:function(n,t,r){"use strict";r.r(t);var e=r(0),i=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("ol",[t("li",[t("em",[t("strong",[n._v("【强制】")])]),n._v(" 在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么\n注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default\n语句并且放在最后，即使它什么代码也没有。")])]),n._v(" "),t("blockquote",[t("p",[n._v("说明：注意 break 是退出 switch 语句块，而 return 是退出方法体。")])]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("em",[t("strong",[n._v("【强制】")])]),n._v(" 当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null\n判断。")])]),n._v(" "),t("blockquote",[t("p",[n._v("反例：如下的代码输出是什么？"),t("br"),n._v("\npublic class SwitchString {"),t("br"),n._v("\npublic static void main(String[] args) {"),t("br"),n._v("\nmethod(null);"),t("br"),n._v("\n}"),t("br"),n._v("\npublic static void method(String param) {"),t("br"),n._v("\nswitch (param) {"),t("br"),n._v("\n// 肯定不是进入这里"),t("br"),n._v('\ncase "sth":'),t("br"),n._v('\nSystem.out.println("it\'s sth");'),t("br"),n._v("\nbreak;"),t("br"),n._v("\n// 也不是进入这里"),t("br"),n._v('\ncase "null":'),t("br"),n._v('\nSystem.out.println("it\'s null");'),t("br"),n._v("\nbreak;"),t("br"),n._v("\n// 也不是进入这里"),t("br"),n._v("\ndefault:"),t("br"),n._v('\nSystem.out.println("default");'),t("br"),n._v("\n}"),t("br"),n._v("\n}"),t("br"),n._v("\n}")])]),n._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("em",[t("strong",[n._v("【强制】")])]),n._v(" 在 if/else/for/while/do 语句中必须使用大括号。")])]),n._v(" "),t("blockquote",[t("p",[n._v("说明：即使只有一行代码，也禁止不采用大括号的编码方式：if (condition) statements;")])]),n._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("em",[t("strong",[n._v("【强制】")])]),n._v(" 三目运算符 condition? 表达式 1 : 表达式 2 中，高度注意表达式 1 和 2 在类型对齐\n时，可能抛出因自动拆箱导致的 NPE 异常。")])]),n._v(" "),t("blockquote",[t("p",[n._v("说明：以下两种场景会触发类型对齐的拆箱操作："),t("br"),n._v("\n1） 表达式 1 或表达式 2 的值只要有一个是原始类型。"),t("br"),n._v("\n2） 表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。"),t("br"),n._v("\n反例："),t("br"),n._v("\nInteger a = 1;"),t("br"),n._v("\nInteger b = 2;"),t("br"),n._v("\nInteger c = null;"),t("br"),n._v("\nBoolean flag = false;"),t("br"),n._v("\n// a"),t("em",[n._v("b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常"),t("br"),n._v("\nInteger result=(flag? a")]),n._v("b : c);")])]),n._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[t("em",[t("strong",[n._v("【强制】")])]),n._v(" 在高并发场景中，避免使用”等于”判断作为中断或退出的条件。")])]),n._v(" "),t("blockquote",[t("p",[n._v("说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件\n来代替。\n反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，\n这样的话，活动无法终止。")])]),n._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[t("p",[t("strong",[n._v("【推荐】")]),n._v(" 当某个方法的代码总行数超过 10 行时，return / throw 等中断逻辑的右大括号后均\n需要加一个空行。\n说明：这样做逻辑清晰，有利于代码阅读时重点关注。")])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("【推荐】")]),n._v(' 表达异常的分支时，少用 if-else 方式，这种方式可以改写成：\nif (condition) {\n...\nreturn obj;\n}\n// 接着写 else 的业务逻辑代码;\n说明：如果非使用 if()...else if()...else...方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。\n正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句\n示例如下：\npublic void findBoyfriend (Man man) {\nif (man.isUgly()) {\nSystem.out.println("本姑娘是外貌协会的资深会员");\nreturn;\n}\nif (man.isPoor()) {\nSystem.out.println("贫贱夫妻百事哀");\nreturn;\n}\nif (man.isBadTemper()) {\nSystem.out.println("银河有多远，你就给我滚多远");\nreturn;\n}\nSystem.out.println("可以先交往一段时间看看");\n}')])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("【推荐】")]),n._v(' 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复\n杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。\n说明：很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本\n非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。\n正例：\n// 伪代码如下\nfinal boolean existed = (file.open(fileName, "w") != null) && (...) || (...);\nif (existed) {\n...\n}\n反例：\npublic final void acquire ( long arg) {\nif (!tryAcquire(arg) &&\nacquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {\nselfInterrupt();\n}')])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("【推荐】")]),n._v(" 不要在其它表达式（尤其是条件表达式）中，插入赋值语句。\n说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。\n反例：\npublic Lock getLock(boolean fair) {\n// 算术表达式中出现赋值操作，容易忽略 count 值已经被改变\nthreshold = (count = Integer.MAX_VALUE) - 1;\n// 条件表达式中出现赋值操作，容易误认为是 sync==fair\nreturn (sync = fair) ? new FairSync() : new NonfairSync();\n}")])])]),n._v(" "),t("p",[n._v("10."),t("strong",[n._v("【推荐】")]),n._v(" 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、\n获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。")]),n._v(" "),t("p",[n._v("11."),t("strong",[n._v("【推荐】")]),n._v(" 避免采用取反逻辑运算符。\n说明：取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。\n正例：使用 if (x < 628) 来表达 x 小于 628。\n反例：使用 if (!(x >= 628)) 来表达 x 小于 628。")]),n._v(" "),t("p",[n._v("12."),t("strong",[n._v("【推荐】")]),n._v(" 公开接口需要进行入参保护，尤其是批量操作的接口。\n反例：某业务系统，提供一个用户批量查询的接口，API 文档上有说最多查多少个，但接口实现上没做任何\n保护，导致调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。")]),n._v(" "),t("p",[n._v("13."),t("em",[n._v("【参考】")]),n._v(" 下列情形，需要进行参数校验：\n1） 调用频次低的方法。\n2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致\n中间执行回退，或者错误，那得不偿失。\n3） 需要极高稳定性和可用性的方法。\n4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。\n5） 敏感权限入口。")]),n._v(" "),t("p",[n._v("14."),t("em",[n._v("【参考】")]),n._v(" 下列情形，不需要进行参数校验：\n1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。\n2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露\n问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可\n以省略。\n3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检\n查或者肯定不会有问题，此时可以不校验参数。")])])}),[],!1,null,null,null);t.default=i.exports}}]);